# 삽입 정렬 O(N^2)

삽입정렬의 핵심 키워드는 이미 `정렬이 완료된것처럼 행동하도록 하는것` 입니다.

저도 처음 들었을 때는 대체 이게 무슨 말인가.. 정렬이 된다는건지 안 된다는건지 헷갈렸습니다.

조금 쉽게 얘기하자면 항상 왼쪽과 비교하여 나보다 클 경우 바꿔주는것 입니다.

- `[ 1, 3, 5, 4, 2 ]` 라는 배열로 삽입정렬의 정렬 과정을 보겠습니다.
    
    ```jsx
    const arr = [ 1, 3, 5, 4, 2 ];
    // 항상 왼쪽과 비교하여 나보다 클 경우 바꿔주는것 입니다.
    
    // 1번째 반복
    1은 비교할 대상이 없기때문에 넘어갑니다 [ 1, 3, 5, 4, 2 ]
    
    // 2번째 반복
    3은 1보다 크기때문에 넘어갑니다 [ 1, 3, 5, 4, 2 ]
    
    // 3번째 반복 
    5는 3보다 크기때문에 넘어갑니다 [ 1, 3, 5, 4, 2 ]
    
    // 4번째 반복 
    4는 5보다 작기 때문에 자리를 바꿉니다. [ 1, 3, 4, 5, 2 ]
    이렇게 바꾸고 나면 끝이 아니라 또 다시 왼쪽과 비교합니다. 4는 3보다 크기때문에 넘어갑니다.
    
    // 5번째 반복 
    2는 5보다 작기 때문에 자리를 바꿉니다. [ 1, 3, 4, 2, 5 ]
    2는 4보다 작기 때문에 자리를 바꿉니다. [ 1, 3, 2, 4, 5 ]
    2는 3보다 작기 때문에 자리를 바꿉니다. [ 1, 2, 3, 4, 5 ]
    2는 1보다 크기때문에 넘어갑니다.
    ```
    

### 코드구현

```jsx
function insertSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let j = i;
    while (arr[j] > arr[j + 1]) {
    // 배열을 순회하면서 왼쪽이 나보다 크다면 스왑을 진행합니다.
      let temp = arr[j];
      arr[j] = arr[j + 1];
      arr[j + 1] = temp;
      j--;
    // 내가 방금 이동한 요소를 쫓아야 하기에 j--를 사용해서 추적합니다.
    }
  }
  return arr;
}
```

### 우세한 시간 복잡도?

여러 정보를 알아보던중 삽입 정렬이 선택정렬, 버블정렬과 같은 시간복잡도를 가지지만

정렬시간이 더 빠르다는점을 보고 신기했다. 같은 시간 복잡도라 하면 비슷한 시간을 소요할 줄 알았지만

예시들을 보며 학습하다보니 아니라는것을 깨달았다.

선택정렬과 버블정렬은 반복마다 두번씩 배열을 순회하지만만 

삽입정렬은 크고작음의 여부만 판단해 배열을 두 번 순회할지 여부를 결정하기에 

`[2, 3, 4, 5, 6, 7, 8, 9, 1]` 이라는 배열이 있을 때  불필요한 반복을 진행하지 않기에

훨씬 최적화된 정렬을 할 수 있었습니다.