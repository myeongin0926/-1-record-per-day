# 토큰 & JWT - 서버 부하 문제의 종지부를 찍다

---

### 🔍 토큰을 공부하게된 계기

로그인 과정에대해 공부를 하고있었다 세션 인증에 관련된것들을 배우면서 궁금한점이 있었다.

만약 동시 이용자가 너무 많다면? 서버의 자원을 사용하는 세션인증이 과연 안전할 수 있을까?

검색을 통해 토큰에 대해 보았고, 이전에 들어본적이 있었다. 오늘은 인증및 인가를 맡는 토큰에 대해 학습해보도록 하겠다.

---

### 📌 Token

토큰은 사용자 인증및 인가에 사용된다.

세션의 단점을 보완하기 위해 나왔다고 하였는데 어떻게 세션의 단점을 보완하는걸까?

세션의 단점을 생각해보자. 사용자의 인증 여부를 서버에 저장함으로써 해당 사용자가 로그인을 한 유저인지 식별했었다.

이를통해 사용자는 세션ID를 가지고 있으며 내가 로그인을 한 유저라는것을 서버에 알리고, 서버는 세션 스토어에서 이를 확인했다.

- 인증과 인가
    
    인증은 말 그대로 내가 사이트의 회원인지를 검증하는것이다. 예로 로그인 과정을 인증과정이라 한다.
    
    인가는 인증을 마친 유저에게 권한을 부여하는것이다. 만약 인가가 불가능하다면 매 요청마다 로그인을 해야할것이다. 
    
    이를 해결해주는것이 세션방식, 토큰 방식이다. 세션 방식은 서버의 부하를 일으킬 수 있다는 단점이 있다.
    

---

### 📌 토큰의 인증방식

**토큰은 세션의 단점인 서버에서의 인증여부 관리를 사용자에게 맡긴다.**

![스크린샷 2023-07-03 오후 8.10.37.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e2a8289c-5a07-4e20-898f-2837a15b83d8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-03_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.10.37.png)

**유저의 정보를 받아 인증 과정을 거치고, 인증이 완료되면 토큰을 생성한다. 서버는 토큰을 서버로 전송하고,** 

**유저가 해당 토큰을 요청과 함께 전송하면  서버에서는 해당 토큰의 유효성을 판단하고 그에맞는 응답을 보낸다.**

생소한 언어들이 많지만 아래에서 더 알아보자.

---

### ⚒️ 토큰의 장점

1. 서버의 부하감소 - 매 요청마다 토큰을 이용해 인증을 진행하기에 세션방식의 서버부하 문제를 해결
2. 확장성 - 더 이상 서버에서 인가를 관리하지 않기 때문에 여러 서비스에서 공통된 토큰으로 접근할 수 있다.
3. 보안 강화 - 토큰은 암호화되어 전송되고 서명되어 인증의 무결성을 보장한다.

---

### 📌 JWT?

토큰 기반 인증 구현 시 대표적으로 사용하는 기술로 `JWT(JSON Web Token)`를 꼽는다.

**JSON 객체에 정보를 담고 이를 토큰으로 암호화하여 전송**할 수 있는 기술이다.

---

### 📌 JWT의 구성

JWT는 다음 그림과 같이 `.`으로 나누어진 세 부분이 존재하며 각각을 Header, Payload, Signature라고 부른다.

![스크린샷 2023-07-03 오후 8.35.44.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f0a2cdc4-c668-4d8e-884c-d5526038fe0f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-03_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.35.44.png)

- **JWT 구조**
    
    ### Header - JWT 유형과 암호화 알고리즘을 지정
    
    ```jsx
    {
    	"alg": "HS256",   // 어떠한 알고리즘으로 암호화 하였는지 명시
    	"typ": "JWT".     // 타입은 대부분 JWT 사용
    }
    ```
    
    ### Payload - 실제로 전달할 데이터를 포함
    
    ```jsx
    {
      "sub": "1234567890",
      "name": "John Doe",
      "iat": 1516239022.  // 토큰 발급시간
      "exp": 1738291123.  // 토큰 만료시간
    }
    ```
    
    ### Signature - 헤더와 페이로드를 조합하여 서명된 문자열 서명은 비밀키를 사용
    
    서명은 해당 토큰이 유효한지를 확인하기 위한 것이다.
    
    ```jsx
    헤더.페이로드.(헤더,페이로드,비밀키를 헤더의 알고리즘으로 암호화한 서명)
    ```
    
    이렇게 서명하는 이유는 비밀키 없이 암호화한것을 서명에 넣으면, 쉽게 디코딩할 수 있기에
    
    서버만이 알고있는 비밀키를 같이 암호화하여 탈취당해도 알아보지 못하도록 하는것이다.
    

---

### 📌 토큰의 한계

다 좋다, 확장성도. 서버의 부하를 줄여주는것도. 하지만 토큰 인증 방식은 한계를 갖고있다. 

1. 무상태성 - 토큰이 탈취되었을때 이를 만료시킬 방법이 없다.
2. 유효기간 - 토큰이 탈취되는 상황을 대비하여 유효기간을 짧게 잡으면 사용자는 그 시간마다 로그인을 해야함
3. 토큰에 여러 정보를 담을 수 있는 만큼, 많은 데이터를 담으면 네트워크 비용 문제가 생긴다.

3번의 단점은 1,2번에 비해 그렇게 큰 문제가 되지 않는다.

그럼 토큰을 만료시킬 방법, 어떻게 할 수 있을까? 정답부터 말하자면 토큰을 강제로 만료시킬 방법은 없다.

---

### 📌 토큰의 한계 극복

토큰은 해당하는 한계를 극복하고자, 두 개의 토큰을 발급하는 방식을 사용했다. 이것이 엑세스 토큰과, 리프레시 토큰이다.

### ****Access Token****

액세스 토큰은 말 그대로 **서버에 접근하기 위한 토큰**으로 앞서 다룬 토큰과 비슷한 역할을 하며

보안을 위해 보통 24시간 정도의 짧은 유효기간이 설정되어 있다.

### **Refresh Token**

리프레시 토큰은 서버 접근을 위한 토큰이 아닌 **액세스 토큰이 만료되었을 때 새로운 액세스 토큰을 발급받기 위해 사용되는 토큰이**다. 
따라서 리프레시 토큰은 액세스 토큰보다 긴 유효기간을 설정

**이렇게 두 가지 각기 다른 토크을 사용하는경우 엑세스 토큰이 만료되더라도, 리프레시 토큰이 남아있다면 로그인을 할 필요가 없다.**

**하지만 이도 토큰의 모든 단점을 해결해주지는 않는다. 리프레시 토큰이 탈취당할경우 긴 시간동안 해결 방법이 없기 때문이다.**

**이로써 무조건 토큰이 좋은것도, 세션이 좋은것도 아니다. 프로그램에 목적에 맞게 사용하는것이 가장 좋을 거 같다.**